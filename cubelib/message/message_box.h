#ifndef MESSAGE_BOX_H
#define MESSAGE_BOX_H

#define MAX_EXPAND_NUM 10

struct message_box
{
	MSG_HEAD head;	 // a fixed size structure to store the message's head
	void * head_template;    // this is the struct template of the head
	void * record_template;  // this is the struct template of the record in this message
	int box_state;           // it show what process_state this message_box  in
	int head_size;		 // it means the message head's size
	BYTE ** record;          // a pointer array to store the record (bin blob format), most time it should be null
	void ** precord;         // a pointer array to store the pointers which point to the record struct in memory
	int * record_size;       // an int value array to store each record's bin blob size 
	BYTE ** expand;   // a fixed size pointer array to store the expand(bin blob format),most time it should be null
	BYTE ** pexpand;  // a fixed size pointer array to store the pointers which point to the expand struct in memory
	int * expand_size;  // an int value array to store each expand's bin blob size
	void * blob;             // the data blob of the message record and/or the message expand, do not include the head.
	int current_offset;      // an int value to show the current offset of the data blob. used when we deal with the data blob  
	void * active_msg;  	// this is the message that active this message, 
				//  should be null if the message is received from connector_proc,
				//  generated by monitor or 
				//  addin want to hide the active message.
}__attribute__((packed));

int __message_add_record_site(void * message,int increment);
int __message_alloc_record_site(void * message);

struct tag_msg_kits
{
	int type;
	void * head_template;
	void * expand_head_template;
	void * expand_uuid_template;
	void * flow_trace_template;
	void * aspect_point_template;
};

#endif
